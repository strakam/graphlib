using System;
using System.IO;
using System.Collections.Generic;

namespace graphlib
{
    public partial class Graph
    {
		int time = 0;
		public List<int> find_aps()
		{
			bool [] visited = new bool[graph.Count];
			int [] disc = new int[graph.Count];
			int [] low = new int[graph.Count];
			bool [] aps = new int[graph.Count];
			for(int i = 0; i < graph.Count; i++)
			{
				low[i] = 30000;
				disc[i] = 300000;
			}
			foreach(KeyValuePair<int, int> kp in indexes)
			{
				if(!visited[kp.Value])
					ap(kp.Key, kp.Key, ref visited, ref disc, ref aps, ref low);
			}
			foreach(int i in aps)
			{
				Console.WriteLine(i);
			}
			return aps;
		}

		void ap(int v, int parent, ref bool [] visited, ref int [] disc, 
				ref bool [] aps, ref int [] low)
		{
			Console.WriteLine("Vchadzam do {0} a davam si cas {1}", v, time);
			visited[v_index(v)] = true;	
			disc[v_index(v)] = time;
			low[v_index(v)] = time;
			if(parent == v && graph[v_index(v)].Count > 1)
				aps.Add(v);
			foreach(Edge e in graph[v_index(v)])
			{
				int next = v_index(e.destination);
				if(!visited[next])
				{
					time++;
					ap(e.destination, v, ref visited, ref disc, ref aps, ref low);
					low[v_index(v)] = Math.Min(low[v_index(v)], low[next]);
					if(disc[v_index(v)] <= low[next])
					{
						Console.WriteLine("AP {0} a low ma {1}", v, low[v_index(v)]);
						aps.Add(v);
					}
				}
				if(e.destination != parent)
					low[v_index(v)] = Math.Min(low[v_index(v)], low[next]);
			}
			Console.WriteLine("Idem z " + v + " a low mam " + low[v_index(v)]);
		}
    }
}
